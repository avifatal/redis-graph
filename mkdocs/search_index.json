{
    "docs": [
        {
            "location": "/", 
            "text": "Redis Graph\n\n\nThis project is a Redis module that implements a graph database. Nodes in the graph represent entities such as persons or places, and connections such as 'visit' are made between the different entities.\n\n\nSuppose we had a person entity representing Barack Obama, it might have two attributes: \"age\" (55) and \"profession\" (ex-president). We could also have another entity represent Hawaii with an attribute \"population\" (1442949). Finally we could construct a simple graph by connecting Barack Obama with an edge representing the relation \"born\" with Hawaii.\n\n\nPrimary features:\n\n\n\n\nA graph database implementation\n\n\nNodes and edges may have attributes\n\n\nNodes and edges can be labeled\n\n\nSupports \nopenCypher\n graph queries\n\n\n\n\nTo see Redis Graph in action see \nDemos\n.\n\n\nQuickstart\n\n\n\n\nBuild the Redis Graph module library\n\n\nRunning tests\n\n\nLoad Redis Graph to Redis\n\n\nUse it from any client\n\n\n\n\nBuilding the module\n\n\nLinux Ubuntu 16.04\n\n\nRequirements:\n\n\n\n\nThe Redis Graph repository: \ngit clone https://github.com/RedisLabsModules/redis-module-graph.git\n\n\nThe build-essential package: \napt-get install build-essential\n\n\n\n\nTo build the module, run \nmake\n in the project's directory:\n\n\nCongratulations! You can find the compiled module library at \nsrc/redisgraph.so\n.\n\n\nRunning tests\n\n\nTo test RedisGraph run the followings:\n\n\n\n\nInstall \npython\n and \npip\n.\n\n\nInstall the Redis Python client and the \nrmtest\n library. \npip install redis rmtest\n\n\n\n\nWith these in place, you should be able to execute the following in the\n\nredis-graph\n directory:\n\n\n$ make test\n\n\n\n\n\nLoading the module to Redis\n\n\nRequirements:\n\n\n\n\nRedis v4.0 or above\n\n\n\n\nWe recommend you have Redis load the module during startup by adding the following to your redis.conf file:\n\n\nloadmodule /path/to/module/redisgraph.so\n\n\n\n\n\nIn the line above replace \n/path/to/module/redisgraph.so\n with the actual path to the module's library. Alternatively, you can have Redis load the module using the following command line argument syntax:\n\n\n~/$ redis-server --loadmodule /path/to/module/redisgraph.so\n\n\n\n\n\nLastly, you can also use the \nMODULE LOAD\n command. Note, however, that \nMODULE LOAD\n is a dangerous command and may be blocked/deprecated in the future due to security considerations.\n\n\nOnce the module has been loaded successfully, the Redis log should have lines similar to:\n\n\n...\n30707:M 20 Jun 02:08:12.314 * Module \ngraph\n loaded from \nredacted\n/src/redisgraph.so\n...\n\n\n\n\n\nUsing Redis Graph\n\n\nBefore using Redis Graph, you should familiarize yourself with its commands and syntax as detailed in the\n\ncommands reference\n document.\n\n\nYou can call Redis Graph's commands from any Redis client.\n\n\nWith \nredis-cli\n\n\n$ redis-cli\n\n127\n.0.0.1:6379\n GRAPH.QUERY social \nCREATE (:person {name: \nroi\n, age: 32, gender: \nmale\n, status: \nmarried\n})\n\n\n\n\n\n\nWith any other client\n\n\nYou can call the module's API using your client's ability to send raw Redis commands. Depending on your client of\nchoice, the exact method for doing that may vary.\n\n\nPython example\n\n\nThis code snippet shows how to use Redis Graph with raw Redis commands from Python with\n\nredis-py\n:\n\n\nimport\n \nredis\n\n\n\nr\n \n=\n \nredis\n.\nStrictRedis\n()\n\n\nreply\n \n=\n \nr\n.\nexecute_command\n(\nGRAPH.QUERY\n,\n \nsocial\n,\n \nCREATE (:person {name:\nroi\n, age:32, gender:\nmale\n, status:\nmarried\n})\n)\n\n\n\n\n\n\nClient libraries\n\n\nSome languages have client libraries that provide support for Redis Graph's commands:\n\n\n\n\n\n\n\n\nProject\n\n\nLanguage\n\n\nLicense\n\n\nAuthor\n\n\nURL\n\n\n\n\n\n\n\n\n\n\nredisgraph-py\n\n\nPython\n\n\nBSD\n\n\nRedis Labs\n\n\nGitHub", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#redis-graph", 
            "text": "This project is a Redis module that implements a graph database. Nodes in the graph represent entities such as persons or places, and connections such as 'visit' are made between the different entities.  Suppose we had a person entity representing Barack Obama, it might have two attributes: \"age\" (55) and \"profession\" (ex-president). We could also have another entity represent Hawaii with an attribute \"population\" (1442949). Finally we could construct a simple graph by connecting Barack Obama with an edge representing the relation \"born\" with Hawaii.  Primary features:   A graph database implementation  Nodes and edges may have attributes  Nodes and edges can be labeled  Supports  openCypher  graph queries   To see Redis Graph in action see  Demos .", 
            "title": "Redis Graph"
        }, 
        {
            "location": "/#quickstart", 
            "text": "Build the Redis Graph module library  Running tests  Load Redis Graph to Redis  Use it from any client", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#building-the-module", 
            "text": "", 
            "title": "Building the module"
        }, 
        {
            "location": "/#linux-ubuntu-1604", 
            "text": "Requirements:   The Redis Graph repository:  git clone https://github.com/RedisLabsModules/redis-module-graph.git  The build-essential package:  apt-get install build-essential   To build the module, run  make  in the project's directory:  Congratulations! You can find the compiled module library at  src/redisgraph.so .", 
            "title": "Linux Ubuntu 16.04"
        }, 
        {
            "location": "/#running-tests", 
            "text": "To test RedisGraph run the followings:   Install  python  and  pip .  Install the Redis Python client and the  rmtest  library.  pip install redis rmtest   With these in place, you should be able to execute the following in the redis-graph  directory:  $ make test", 
            "title": "Running tests"
        }, 
        {
            "location": "/#loading-the-module-to-redis", 
            "text": "Requirements:   Redis v4.0 or above   We recommend you have Redis load the module during startup by adding the following to your redis.conf file:  loadmodule /path/to/module/redisgraph.so  In the line above replace  /path/to/module/redisgraph.so  with the actual path to the module's library. Alternatively, you can have Redis load the module using the following command line argument syntax:  ~/$ redis-server --loadmodule /path/to/module/redisgraph.so  Lastly, you can also use the  MODULE LOAD  command. Note, however, that  MODULE LOAD  is a dangerous command and may be blocked/deprecated in the future due to security considerations.  Once the module has been loaded successfully, the Redis log should have lines similar to:  ...\n30707:M 20 Jun 02:08:12.314 * Module  graph  loaded from  redacted /src/redisgraph.so\n...", 
            "title": "Loading the module to Redis"
        }, 
        {
            "location": "/#using-redis-graph", 
            "text": "Before using Redis Graph, you should familiarize yourself with its commands and syntax as detailed in the commands reference  document.  You can call Redis Graph's commands from any Redis client.", 
            "title": "Using Redis Graph"
        }, 
        {
            "location": "/#with-redis-cli", 
            "text": "$ redis-cli 127 .0.0.1:6379  GRAPH.QUERY social  CREATE (:person {name:  roi , age: 32, gender:  male , status:  married })", 
            "title": "With redis-cli"
        }, 
        {
            "location": "/#with-any-other-client", 
            "text": "You can call the module's API using your client's ability to send raw Redis commands. Depending on your client of\nchoice, the exact method for doing that may vary.", 
            "title": "With any other client"
        }, 
        {
            "location": "/#python-example", 
            "text": "This code snippet shows how to use Redis Graph with raw Redis commands from Python with redis-py :  import   redis  r   =   redis . StrictRedis ()  reply   =   r . execute_command ( GRAPH.QUERY ,   social ,   CREATE (:person {name: roi , age:32, gender: male , status: married }) )", 
            "title": "Python example"
        }, 
        {
            "location": "/#client-libraries", 
            "text": "Some languages have client libraries that provide support for Redis Graph's commands:     Project  Language  License  Author  URL      redisgraph-py  Python  BSD  Redis Labs  GitHub", 
            "title": "Client libraries"
        }, 
        {
            "location": "/commands/", 
            "text": "Redis Graph Commands\n\n\nGRAPH.EXPLAIN\n\n\nConstructs a query execution plan but does not run it. Inspect this execution plan to better\nunderstand how your query will get executed.\n\n\nArguments: \nGraph name, Query\n\n\nReturns: \nString representation of a query execution plan\n\n\nGRAPH.EXPLAIN us_government \nMATCH (p:president)-[:born]-\n(h:state {name:\nHawaii\n}) RETURN p\n\n\n\n\n\n\nGRAPH.QUERY\n\n\nExecutes the given query against a specified graph.\n\n\nArguments: \nGraph name, Query\n\n\nReturns: \nResult set\n\n\nGRAPH.QUERY us_government \nMATCH (p:president)-[:born]-\n(:state {name:\nHawaii\n}) RETURN p\n\n\n\n\n\n\nQuery language\n\n\nThe syntax is based on \nopenCypher\n and currently only a subset of the language is\nsupported.\n\n\n\n\nClauses\n\n\nFunctions\n\n\n\n\nA query is composed of five parts:\n\n\nQuery structure\n\n\n\n\nMATCH\n\n\nWHERE\n\n\nRETURN\n\n\nORDER BY\n\n\nLIMIT\n\n\nCREATE\n\n\nDELETE\n\n\nSET\n\n\n\n\nMATCH\n\n\nDescribes the relationship between queried entities, it is composed of three parts:\n\n\n\n\nSource node (S)\n\n\nRelationship [R]\n\n\nDestination node (D)\n\n\n\n\nCombining the three together\n\n(S)-[R]-\n(D)\n\n\nEach graph entity node/edge can contain an alias and a label, but both can be left empty if needed.\n\n\nEntity structure: \nalias:label {filters}\n alias, label and filters are all optional.\n\n\nExample:\n\n\n(\na:actor\n)\n-\n[\n:act\n]\n-\n(\nm:movie \n{\ntitle:\nstraight outta compton\n})\n\n\n\n\n\n\na\n is an alias for the source node, which we'll be able to refer to at different places within our query.\n\n\nactor\n is the label under which this node is marked.\n\n\nact\n is the relationship type.\n\n\nm\n an alias for the destination node.\n\n\nmovie\n destination node is of \"type\" movie.\n\n\n{title:\"straight outta compton\"}\n requires the node's title attribute to equal \"straight outta compton\".\n\n\nAs such, we're interested in actor entities which have the relation \"act\" with \nthe\n entity representing the\n\"straight outta compton\" movie.\n\n\nIt is possible to describe broader relationships by composing a multi-hop query such as:\n\n\n(\nme \n{\nname:\nswilly\n})\n-\n[\n:friends_with\n]\n-\n()\n-\n[\n:friends_with\n]\n-\n(\nfof\n)\n\n\n\n\n\n\nHere we're interested in finding out who are my friends' friends.\n\n\nNodes can have more than one edge coming in or out of them, for instance:\n\n\n(\nme \n{\nname:\nswilly\n})\n-\n[\n:visited\n]\n-\n(\nc:country\n)\n-\n[\n:visited\n]\n-\n(\nfriend\n)\n-\n[\n:friends_with\n]\n-\n({\nname:\nswilly\n})\n\n\n\n\n\n\nHere we're interested in knowing which of my friends have visited at least one country i've been to.\n\n\nWHERE\n\n\nThis clause is not mandatory, but in order to filter results you can define predicates of two kinds:\n\n\n1.Compare against constant value: \nalias.property operation value\n\nwhere \nvalue\n is a primitive type (int, float, string and boolean)\n\n\n2.Compare between nodes properties: \nalias.property operation alias.property\n\n\nSupported operations:\n\n\n\n\n=\n\n\n!=\n\n\n\n\n=\n\n\n\n\n=\n\n\n\n\nPredicates can be combined using AND / OR. Be sure to wrap predicates within parentheses to control precedence.\n\n\nExamples:\n\n\nWHERE \n(\nactor.name \n=\n \njohn doe\n OR movie.rating \n \n8\n.8\n)\n AND movie.votes \n=\n \n250\n)\n\n\n\n\n\n\nWHERE actor.age \n=\n director.age AND actor.age \n \n32\n\n\n\n\n\n\nIt is also possible to specify equality predicates within nodes and edges using the curly braces as such:\n\n\n(\n:president \n{\nname:\nBarack Obama\n})\n-\n[\n:won \n{\nterm:2\n}]\n-\n(\n:state\n)\n\n\n\n\n\n\nHere we've required that the president node's name will have the value \"Barack Obama\"\nand the won edge term property will equal 2.\n\n\nThere's no difference between inlined predicates and predicates specified within the WHERE clause.\n\n\nRETURN\n\n\nIn its simple form, Return defines which properties the returned result-set will contain.\nIts structure is a list of \nalias.property\n seperated by commas.\nFor convenience, it's possible to specify the alias only when you're interested in every attribute an entity possesses,\nand don't want to specify each attribute individually. e.g.\n\n\nRETURN movie.title, actor\n\n\n\n\n\nUse the DISTINCT keyword to remove duplications within the result-set:\n\n\nRETURN DISTINCT friend_of_friend.name\n\n\n\n\n\nIn the above example, suppose we have two friends, Joe and Miesha,\nand both know Dominick. Then DISTINCT will make sure that Dominick will only appear once\nin the final result-set.\n\n\nReturn can also be used to aggregate data similar to SQL group by. Once an aggregation function is added to the return\nlist, all other \"none\" aggregated values are considered as group keys, for example:\n\n\nRETURN movie.title, MAX\n(\nactor.age\n)\n, MIN\n(\nactor.age\n)\n\n\n\n\n\n\nHere we group data by movie title and for each movie, we find its youngest and oldest actor age.\n\n\nAggregations\n\n\nSupported aggregation functions:\n\n\n\n\nsum\n\n\navg\n\n\nmin\n\n\nmax\n\n\ncount\n\n\n\n\nORDER BY\n\n\nSpecifies that the output should be sorted and how.\n\n\nYou can order by multiple properties by stating each variable in the ORDER BY clause.\nThe result will be sorted by the first variable listed, and for equal values, go to the next property in the ORDER BY\nclause, and so on.\n\n\nORDER BY \nalias.property list\n \n[\nASC/DESC\n]\n\n\n\n\n\n\nBelow we sort our friends by height. For similar heights, weight is used to break even.\n\n\nORDER BY friend.height, friend.weight DESC\n\n\n\n\n\nLIMIT\n\n\nAlthough not mandatory, in order to limit the number of records returned by a query, you can\nuse the limit clause:\n\n\nLIMIT \nmax records to \nreturn\n\n\n\n\n\n\nIf not specified, there's no limit to the number of records returned by a query.\n\n\nCREATE\n\n\nCREATE query is used to introduce new nodes and relationships.\nThe simplest example of CREATE would be a single node creation:\n\n\nCREATE \n(\nn\n)\n\n\n\n\n\n\nIt's possible to create multiple entities by seperating them with a comma.\n\n\nCREATE \n(\nn\n)\n,\n(\nm\n)\n\n\n\n\n\n\nLabel and properties can be specified at creation time\n\n\nCREATE \n(\n:person \n{\nname: \nKurt\n, age:27\n})\n\n\n\n\n\n\nAdding relations between nodes, in the following example we first locate an existing source node,\nonce found we create a new relationship and destination node.\n\n\nMATCH\n(\na:person\n)\n\nWHERE a.name \n=\n \nKurt\n\nCREATE \n(\na\n)\n-\n[\nmember \n{\nposition:\nlead singer\n}]\n-\n(\n:band \n{\nname:\nNirvana\n})\n\nRETURN\n\n\n\n\n\nHere the source node is a bounded node while the destination node is unbounded,\nas a result a new node is created representing the band Nirvana and a new relation connects Kurt as the lead singer of the band.\n\n\nLastly we'll create a complete pattern, all entities within the pattern which are not bounded will be created.\n\n\nCREATE \n\n(\njim:person\n{\nname:\nJim\n, age:29\n})\n-\n[\nfriends\n]\n-\n(\npam:person \n{\nname:\nPam\n, age:27\n})\n-\n[\nworks\n]\n-\n(\n:employer \n{\nname:\nDunder Mifflin\n})\n\nRETURN\n\n\n\n\n\nThis query will create three nodes and two relationships.\n\n\nDELETE\n\n\nDELETE query is used to remove both nodes and relationships, please remember that deleting a node will also delete\nall of its incoming and outgoing relationships.\n\n\nDelete a node and all of its relationships:\n\n\nMATCH \n(\np:person \n{\nname:\nJim\n})\n\nDELETE p\n\n\n\n\n\nDelete a relationship\n\n\nMATCH \n(\np:person \n{\nname:\nJim\n})\n-\n[\nr:friends\n]\n-\n()\n\nDELETE r\n\n\n\n\n\nThis query will delete all \nfriend\n outgoing relationships from the node with the name 'Jim'.\n\n\nSET\n\n\nThe \nSET\n clause is used to update properties on nodes and relationships.\n\n\nTo set a property on a node or relationship, use \nSET\n.\n\n\nQuery.\n\n\nMATCH \n(\nn \n{\n name: \nJim\n \n})\n SET n.name \n=\n \nBob\n\n\n\n\n\n\nSet multiple properties using one \nSET\n clause\nIf you want to set multiple properties in one go, simply separate them with a comma.\n\n\nQuery.\n\n\nMATCH \n(\nn \n{\n name: \nJim\n, age:32 \n})\n\nSET n.age \n=\n \n33\n, n.name \n=\n \nBob\n\n\n\n\n\n\nFunctions\n\n\nThis section contains information on all supported functions from the OpenCypher query language.\n\n\n\n\nAggregating functions\n\n\nMathematical functions\n\n\nString functions\n\n\n\n\nAggregating functions\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\navg()\n\n\nReturns the average of a set of numeric values.\n\n\n\n\n\n\ncount()\n\n\nReturns the number of values or rows.\n\n\n\n\n\n\nmax()\n\n\nReturns the maximum value in a set of values.\n\n\n\n\n\n\nmin()\n\n\nReturns the minimum value in a set of values.\n\n\n\n\n\n\nsum()\n\n\nReturns the sum of a set of numeric values.\n\n\n\n\n\n\n\n\nMathematical functions\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nabs()\n\n\nReturns the absolute value of a number.\n\n\n\n\n\n\nceil()\n\n\nReturns the smallest floating point number that is greater than or equal to a number and equal to\n\n\n\n\n\n\nfloor()\n\n\nReturns the largest floating point number that is less than or equal to a number and equal to a\n\n\n\n\n\n\nrand()\n\n\nReturns a random floating point number in the range from 0 to 1; i.e. [0,1].\n\n\n\n\n\n\nround()\n\n\nReturns the value of a number rounded to the nearest integer.\n\n\n\n\n\n\nsign()\n\n\nReturns the signum of a number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number.\n\n\n\n\n\n\n\n\nString functions\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nleft()\n\n\nReturns a string containing the specified number of leftmost characters of the original string.\n\n\n\n\n\n\nlTrim()\n\n\nReturns the original string with leading whitespace removed.\n\n\n\n\n\n\nreverse()\n\n\nReturns a string in which the order of all\n\n\n\n\n\n\nright()\n\n\nReturns a string containing the specified number of rightmost characters of the original string.\n\n\n\n\n\n\nrTrim()\n\n\nReturns the original string with trailing whitespace removed.\n\n\n\n\n\n\nsubstring()\n\n\nReturns a substring of the original string, beginning with a 0-based index start and length.\n\n\n\n\n\n\ntoLower()\n\n\nReturns the original string in lowercase.\n\n\n\n\n\n\ntoString()\n\n\nConverts an integer, float or boolean value to a string.\n\n\n\n\n\n\ntoUpper()\n\n\nReturns the original string in uppercase.\n\n\n\n\n\n\ntrim()\n\n\nReturns the original string with leading and trailing whitespace removed.", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#redis-graph-commands", 
            "text": "", 
            "title": "Redis Graph Commands"
        }, 
        {
            "location": "/commands/#graphexplain", 
            "text": "Constructs a query execution plan but does not run it. Inspect this execution plan to better\nunderstand how your query will get executed.  Arguments:  Graph name, Query  Returns:  String representation of a query execution plan  GRAPH.EXPLAIN us_government  MATCH (p:president)-[:born]- (h:state {name: Hawaii }) RETURN p", 
            "title": "GRAPH.EXPLAIN"
        }, 
        {
            "location": "/commands/#graphquery", 
            "text": "Executes the given query against a specified graph.  Arguments:  Graph name, Query  Returns:  Result set  GRAPH.QUERY us_government  MATCH (p:president)-[:born]- (:state {name: Hawaii }) RETURN p", 
            "title": "GRAPH.QUERY"
        }, 
        {
            "location": "/commands/#query-language", 
            "text": "The syntax is based on  openCypher  and currently only a subset of the language is\nsupported.   Clauses  Functions   A query is composed of five parts:", 
            "title": "Query language"
        }, 
        {
            "location": "/commands/#query-structure", 
            "text": "MATCH  WHERE  RETURN  ORDER BY  LIMIT  CREATE  DELETE  SET", 
            "title": "Query structure"
        }, 
        {
            "location": "/commands/#match", 
            "text": "Describes the relationship between queried entities, it is composed of three parts:   Source node (S)  Relationship [R]  Destination node (D)   Combining the three together (S)-[R]- (D)  Each graph entity node/edge can contain an alias and a label, but both can be left empty if needed.  Entity structure:  alias:label {filters}  alias, label and filters are all optional.  Example:  ( a:actor ) - [ :act ] - ( m:movie  { title: straight outta compton })   a  is an alias for the source node, which we'll be able to refer to at different places within our query.  actor  is the label under which this node is marked.  act  is the relationship type.  m  an alias for the destination node.  movie  destination node is of \"type\" movie.  {title:\"straight outta compton\"}  requires the node's title attribute to equal \"straight outta compton\".  As such, we're interested in actor entities which have the relation \"act\" with  the  entity representing the\n\"straight outta compton\" movie.  It is possible to describe broader relationships by composing a multi-hop query such as:  ( me  { name: swilly }) - [ :friends_with ] - () - [ :friends_with ] - ( fof )   Here we're interested in finding out who are my friends' friends.  Nodes can have more than one edge coming in or out of them, for instance:  ( me  { name: swilly }) - [ :visited ] - ( c:country ) - [ :visited ] - ( friend ) - [ :friends_with ] - ({ name: swilly })   Here we're interested in knowing which of my friends have visited at least one country i've been to.", 
            "title": "MATCH"
        }, 
        {
            "location": "/commands/#where", 
            "text": "This clause is not mandatory, but in order to filter results you can define predicates of two kinds:  1.Compare against constant value:  alias.property operation value \nwhere  value  is a primitive type (int, float, string and boolean)  2.Compare between nodes properties:  alias.property operation alias.property  Supported operations:   =  !=   =   =   Predicates can be combined using AND / OR. Be sure to wrap predicates within parentheses to control precedence.  Examples:  WHERE  ( actor.name  =   john doe  OR movie.rating    8 .8 )  AND movie.votes  =   250 )   WHERE actor.age  =  director.age AND actor.age    32   It is also possible to specify equality predicates within nodes and edges using the curly braces as such:  ( :president  { name: Barack Obama }) - [ :won  { term:2 }] - ( :state )   Here we've required that the president node's name will have the value \"Barack Obama\"\nand the won edge term property will equal 2.  There's no difference between inlined predicates and predicates specified within the WHERE clause.", 
            "title": "WHERE"
        }, 
        {
            "location": "/commands/#return", 
            "text": "In its simple form, Return defines which properties the returned result-set will contain.\nIts structure is a list of  alias.property  seperated by commas.\nFor convenience, it's possible to specify the alias only when you're interested in every attribute an entity possesses,\nand don't want to specify each attribute individually. e.g.  RETURN movie.title, actor  Use the DISTINCT keyword to remove duplications within the result-set:  RETURN DISTINCT friend_of_friend.name  In the above example, suppose we have two friends, Joe and Miesha,\nand both know Dominick. Then DISTINCT will make sure that Dominick will only appear once\nin the final result-set.  Return can also be used to aggregate data similar to SQL group by. Once an aggregation function is added to the return\nlist, all other \"none\" aggregated values are considered as group keys, for example:  RETURN movie.title, MAX ( actor.age ) , MIN ( actor.age )   Here we group data by movie title and for each movie, we find its youngest and oldest actor age.", 
            "title": "RETURN"
        }, 
        {
            "location": "/commands/#aggregations", 
            "text": "Supported aggregation functions:   sum  avg  min  max  count", 
            "title": "Aggregations"
        }, 
        {
            "location": "/commands/#order-by", 
            "text": "Specifies that the output should be sorted and how.  You can order by multiple properties by stating each variable in the ORDER BY clause.\nThe result will be sorted by the first variable listed, and for equal values, go to the next property in the ORDER BY\nclause, and so on.  ORDER BY  alias.property list   [ ASC/DESC ]   Below we sort our friends by height. For similar heights, weight is used to break even.  ORDER BY friend.height, friend.weight DESC", 
            "title": "ORDER BY"
        }, 
        {
            "location": "/commands/#limit", 
            "text": "Although not mandatory, in order to limit the number of records returned by a query, you can\nuse the limit clause:  LIMIT  max records to  return   If not specified, there's no limit to the number of records returned by a query.", 
            "title": "LIMIT"
        }, 
        {
            "location": "/commands/#create", 
            "text": "CREATE query is used to introduce new nodes and relationships.\nThe simplest example of CREATE would be a single node creation:  CREATE  ( n )   It's possible to create multiple entities by seperating them with a comma.  CREATE  ( n ) , ( m )   Label and properties can be specified at creation time  CREATE  ( :person  { name:  Kurt , age:27 })   Adding relations between nodes, in the following example we first locate an existing source node,\nonce found we create a new relationship and destination node.  MATCH ( a:person ) \nWHERE a.name  =   Kurt \nCREATE  ( a ) - [ member  { position: lead singer }] - ( :band  { name: Nirvana }) \nRETURN  Here the source node is a bounded node while the destination node is unbounded,\nas a result a new node is created representing the band Nirvana and a new relation connects Kurt as the lead singer of the band.  Lastly we'll create a complete pattern, all entities within the pattern which are not bounded will be created.  CREATE  ( jim:person { name: Jim , age:29 }) - [ friends ] - ( pam:person  { name: Pam , age:27 }) - [ works ] - ( :employer  { name: Dunder Mifflin }) \nRETURN  This query will create three nodes and two relationships.", 
            "title": "CREATE"
        }, 
        {
            "location": "/commands/#delete", 
            "text": "DELETE query is used to remove both nodes and relationships, please remember that deleting a node will also delete\nall of its incoming and outgoing relationships.  Delete a node and all of its relationships:  MATCH  ( p:person  { name: Jim }) \nDELETE p  Delete a relationship  MATCH  ( p:person  { name: Jim }) - [ r:friends ] - () \nDELETE r  This query will delete all  friend  outgoing relationships from the node with the name 'Jim'.", 
            "title": "DELETE"
        }, 
        {
            "location": "/commands/#set", 
            "text": "The  SET  clause is used to update properties on nodes and relationships.  To set a property on a node or relationship, use  SET .  Query.  MATCH  ( n  {  name:  Jim   })  SET n.name  =   Bob   Set multiple properties using one  SET  clause\nIf you want to set multiple properties in one go, simply separate them with a comma.  Query.  MATCH  ( n  {  name:  Jim , age:32  }) \nSET n.age  =   33 , n.name  =   Bob", 
            "title": "SET"
        }, 
        {
            "location": "/commands/#functions", 
            "text": "This section contains information on all supported functions from the OpenCypher query language.   Aggregating functions  Mathematical functions  String functions", 
            "title": "Functions"
        }, 
        {
            "location": "/commands/#aggregating-functions", 
            "text": "Function  Description      avg()  Returns the average of a set of numeric values.    count()  Returns the number of values or rows.    max()  Returns the maximum value in a set of values.    min()  Returns the minimum value in a set of values.    sum()  Returns the sum of a set of numeric values.", 
            "title": "Aggregating functions"
        }, 
        {
            "location": "/commands/#mathematical-functions", 
            "text": "Function  Description      abs()  Returns the absolute value of a number.    ceil()  Returns the smallest floating point number that is greater than or equal to a number and equal to    floor()  Returns the largest floating point number that is less than or equal to a number and equal to a    rand()  Returns a random floating point number in the range from 0 to 1; i.e. [0,1].    round()  Returns the value of a number rounded to the nearest integer.    sign()  Returns the signum of a number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number.", 
            "title": "Mathematical functions"
        }, 
        {
            "location": "/commands/#string-functions", 
            "text": "Function  Description      left()  Returns a string containing the specified number of leftmost characters of the original string.    lTrim()  Returns the original string with leading whitespace removed.    reverse()  Returns a string in which the order of all    right()  Returns a string containing the specified number of rightmost characters of the original string.    rTrim()  Returns the original string with trailing whitespace removed.    substring()  Returns a substring of the original string, beginning with a 0-based index start and length.    toLower()  Returns the original string in lowercase.    toString()  Converts an integer, float or boolean value to a string.    toUpper()  Returns the original string in uppercase.    trim()  Returns the original string with leading and trailing whitespace removed.", 
            "title": "String functions"
        }, 
        {
            "location": "/design/", 
            "text": "RedisGraph: A High Performance In-Memory Graph Database as a Redis Module\n\n\nAbstract\n\n\nGraph based data is everywhere now days, Facebook, Google, Twitter and Pinterest are only a few who've realize the power\nbehind relationship data and are utilizing it to the fullest, as a direct result we see a rise both in interest and\nvariety of graph data solutions.\n\n\nWith the introduction of \nRedis Modules\n we've seen the great potential of introducing a\ngraph data structure to Redis arsenal, a native C implementation with emphasis on performance was developed to bring\nnew graph database capabilities to Redis, the \nRedisGraph\n is now\navailable as an open source project on \nGitHub\n.\n\n\nIn this document we'll discuss the internal design and feature of RedisGraph and demonstrate its current capabilities.\n\n\nRedisGraph At-a-Glance\n\n\nRedisGraph is a graph database developed from scratch on top of Redis, using the new Redis Modules API to extend Redis\nwith new commands and capabilities. Its main features include:\n- Simple, fast indexing and querying\n- Data stored in RAM, using memory-efficient custom data structures\n- On disk persistence\n- Tabular result sets\n- Simple and popular graph query language (Cypher)\n- Data Filtering, Aggregation and ordering\n\n\nA Little Taste: RedisGraph in Action\n\n\nLet\u2019s look at some of the key concepts of RedisGraph using this example over the redis-cli tool:\n\n\nConstructing a graph:\n\n\nIt is a common concept to represent entities as nodes within a graph, In this example, we'll create a small graph with both actors and movies as its entities,\nan \"act\" relation will connect actors to movies they casted in.\nWe use the graph.QUERY command to issue a CREATE query which will introduce new entities and relations to our graph.\n\n\ngraph.QUERY \ngraph_id\n \nCREATE (:\nlabel\n {\nattribute_name\n:\nattribute_value\n,...})\n\n\n\n\n\n\ngraph.QUERY \ngraph_id\n \nCREATE (\nsource_node_alias\n)-[\nrelation\n {\nattribute_name\n:\nattribute_value\n,...}]-\n(\ndest_node_alias\n)\n\n\n\n\n\n\nConstruct our graph in one go:\n\n\ngraph.QUERY IMDB \nCREATE (aldis:actor {name: \nAldis Hodge\n, birth_year: 1986}),\n\n\n                         (oshea:actor {name: \nOShea Jackson\n, birth_year: 1991}),\n\n\n                         (corey:actor {name: \nCorey Hawkins\n, birth_year: 1988}),\n\n\n                         (neil:actor {name: \nNeil Brown\n, birth_year: 1980}),\n\n\n                         (compton:movie {title: \nStraight Outta Compton\n, genre: \nBiography\n, votes: 127258, rating: 7.9, year: 2015}),\n\n\n                         (neveregoback:movie {title: \nNever Go Back\n, genre: \nAction\n, votes: 15821, rating: 6.4, year: 2016}),\n\n\n                         (aldis)-[:act]-\n(neveregoback),\n\n\n                         (aldis)-[:act]-\n(compton),\n\n\n                         (oshea)-[:act]-\n(compton),\n\n\n                         (corey)-[:act]-\n(compton),\n\n\n                         (neil)-[:act]-\n(compton)\n\n\n\n\n\n\nQuerying the graph:\n\n\nRedisGraph exposes a subset of openCypher graph language, although only a number of language capabilities are supported\nthere's enough functionality to extract valuable insights from your graphs, to execute a query we use the GRAPH.QUERY\ncommand:\n\n\nGRAPH.QUERY \ngraph_id\n \nquery\n\n\n\n\n\n\nLet's execute a number of queries against our movies graph:\n\n\nFind the sum, max, min and avg age of the Straight Outta Compton cast:\n\n\nGRAPH.QUERY IMDB \nMATCH (a:actor)-[act]-\n(m:movie {title:\nStraight Outta Compton\n})\n\n\nRETURN m.title, SUM(a.age), MAX(a.age), MIN(a.age), AVG(a.age)\n\n\n\n\n\n\nRedisGraph will reply with:\n\n\n1\n)\n \nm.title, SUM(a.age), MAX(a.age), MIN(a.age), AVG(a.age)\n\n\n2\n)\n \nStraight Outta Compton,123.000000,37.000000,26.000000,30.750000\n\n\n\n\n\n\nThe first row is our result-set hearder which name each column according to the return clause.\nSecond row contains our query result.\n\n\nLet's try another query, this time we'll find in how many movies each actor played.\n\n\nGRAPH.QUERY IMDB \nMATCH (actor)-[act]-\n(movie) RETURN actor.name, COUNT(movie.title) AS movies_count ORDER BY\n\n\nmovies_count DESC\n\n\n\n1\n)\n \nactor.name, movies_count\n\n\n2\n)\n \nAldis Hodge,2.000000\n\n\n3\n)\n \nO\nShea Jackson,1.000000\n\n\n4\n)\n \nCorey Hawkins,1.000000\n\n\n5\n)\n \nNeil Brown,1.000000\n\n\n\n\n\n\nThe Theory: Ideas behind RedisGraph\n\n\nDifferent graph databases uses different structures for representing a graph. Some use adjacency list, others might use\nan adjacency matrix. Each structure has its advantages and disadvantages. For RedisGraph it was crucial to find a data\nstructure which will enable us to perform fast searches on the graph, and thus we have decided to use a concept called\n\nHexastore\n in order to hold all the relationships within the graph.\n\n\nGraph representation: Hexastore\n\n\nA Hexastore is simply a list of triplets, where each triplet is composed of three parts:\n\n\n\n\nSubject\n\n\nPredicate\n\n\nObject\n\n\n\n\nWhere the Subject refers to a source node, predicate represents a relationship and the object refers to a destination\nnode.\nFor each relationship within the graph our hexastore will contain all six permutation of the source node, relationship\nedge and destination node.\nFor example consider the following relation:\n\n\n(Aldis_Hodge)-[act]-\n(Straight_Outta_Compton)\n\n\nwhere:\n- Aldis_Hodge is the source node\n- act is the relationship\n- Straight_Outta_Compton is the destination node\n\n\nAll six possibilities of representing this connection are as follows:\n\n\nSPO:Aldis_Hodge:act:Straight_Outta_Compton\nSOP:Aldis_Hodge:Straight_Outta_Compton:act\nPOS:act:Straight_Outta_Compton:Aldis_Hodge\nPSO:act:Aldis_Hodge:Straight_Outta_Compton\nOPS:Straight_Outta_Compton:act:Aldis_Hodge\nOSP:Straight_Outta_Compton:Aldis_Hodge:act\n\n\n\n\n\nWith the Hexastore constructed we can easily search our graph, suppose I would like to find the cast of the movie\nStraight Outta Compton, all I've to do is search my Hexastore for all strings containing the\nprefix: \nOPS:Straight_Outta_Compton:act:*\n\n\nOr if I'm interested in all the movies Aldis Hodge played in, I can search for all strings containing the\nprefix: \nSPO:Aldis_Hodge:act:*\n\n\nAlthough a Hexastore uses plenty of memory (six triplets for each relation), we're using a trie data structure which is\nnot only fast in terms of search but is also memory efficient as it doesn't create duplication of string prefixes it\nalready seen.\n\n\nQuery language: openCypher\n\n\nThere are a number of Graph Query languages, we didn't want to reinvent the wheel and come up with our own language,\nand so we've decided to implement a subset of one of the most popular graph query language out there openCypher.\nThe Open-Cypher project provides means to create a parser for the language, although convenient\nwe decided to create our own parser with Lex as a tokenizer and Lemon which generates a C target parser.\n\n\nAs mentioned only a subset of the language is supported, but it is our intention to continue adding new capabilities\nand extend the language.\n\n\nRuntime: query execution\n\n\nLet's review the steps our module takes when executing a query.\nConsider the following query which finds all actors who've played alongside Aldis Hodge and are over 30 years old:\n\n\nMATCH (aldis::actor {name:\nAldis Hodge\n})-[act]-\n(m:movie)\n-[act]-(a:actor) WHERE a.age \n 30 RETURN m.title, a.name\n\n\n\n\n\nRedisGraph will\n- Parse query, build abstract syntax tree (AST)\n- Construct a query execution plan composed of:\n  - Label scan operation\n  - Filter operation (filter tree)\n  - Expand operation\n  - Expand into operation\n- Execute plan\n- Populate result-set with matching entities attributes\n\n\nQuery parser\n\n\nGiven a valid query the parser will generate an AST containing six primary nodes one for each clause:\n\n\n\n\nMATCH\n\n\nCREATE\n\n\nDELETE\n\n\nWHERE\n\n\nRETURN\n\n\nORDER\n\n\n\n\nGenerating an abstract syntax tree is a common way of describing and structuring a language.\n\n\nFilter tree\n\n\nA query can filter out entities by creating predicates. In our example we're filtering actors which are younger then 30.\nIt's possible to combine predicates using the OR, AND keywords to form granular conditions. During runtime the WHERE\nclause is used to construct a filter tree. Each node within the tree is either a condition e.g. A \n B or an operation\n(AND/OR). When finding candidate entities they are passed through the tree and get evaluated.\n\n\nQuery processing\n\n\nThe MATCH clause describes relations between queried entities (nodes), a node can have an alias which will allow us to\nrefer to it at later stages within the executing query lifetime (WHERE, RETURN clause), but all nodes must eventually\nbe assign an ID. The process of assigning IDs to nodes is refered to as the search phase.\n\n\nDuring the search we'll be querying the Hexastore for IDs according to the MATCH clause structure.\nFor instance, in our example we'll start our search by looking for movies in which Aldis Hodge played in.\nFor each movie we'll extend our search to find out which other actors played in the current processed movie.\n\n\nAs you might imagine the search process is a recursive operation which traverse the graph. At each step a new ID is\ndiscovered. Once every node has an ID assigned to it we can be assured that current entities have passed our filters.\nAt this point we can extract requested attributes (as specified in the return clause) and append a new record to the\nfinal result set.\n\n\nBenchmarks\n\n\nDepending on the underlying hardware results may vary. That said, inserting a new relationship is done in O(1).\nRedisGraph is able to create 100K new relations within one second.\n\n\nRetrieving data really depends on the size of the graph and the type of query you're executing.\nOn a small size graph ~1000 entities and ~2500 edges, RedisGraph is able to perform ~65K friend of a friend query\nevery second.\n\n\nIt's worth mentioning that besides the hexastore, entities are not indexed. It\u2019s our intention to introduce entities\nindexing which should decrease query execution time dramatically.\n\n\nLicense\n\n\nRedis-Graph is published under AGPL-3.0.\n\n\nConclusion\n\n\nAlthough RedisGraph is still a young project, it can be an alternative to other graph databases. With its subset of\noperations one can use it to analyze and explore its graph data. Being a Redis module this project is accessible from\nevery Redis client without the need to make any adjustments. It's our intention to keep on improving and extending\nRedisGraph with the help of the open source community.", 
            "title": "Design"
        }, 
        {
            "location": "/design/#redisgraph-a-high-performance-in-memory-graph-database-as-a-redis-module", 
            "text": "", 
            "title": "RedisGraph: A High Performance In-Memory Graph Database as a Redis Module"
        }, 
        {
            "location": "/design/#abstract", 
            "text": "Graph based data is everywhere now days, Facebook, Google, Twitter and Pinterest are only a few who've realize the power\nbehind relationship data and are utilizing it to the fullest, as a direct result we see a rise both in interest and\nvariety of graph data solutions.  With the introduction of  Redis Modules  we've seen the great potential of introducing a\ngraph data structure to Redis arsenal, a native C implementation with emphasis on performance was developed to bring\nnew graph database capabilities to Redis, the  RedisGraph  is now\navailable as an open source project on  GitHub .  In this document we'll discuss the internal design and feature of RedisGraph and demonstrate its current capabilities.", 
            "title": "Abstract"
        }, 
        {
            "location": "/design/#redisgraph-at-a-glance", 
            "text": "RedisGraph is a graph database developed from scratch on top of Redis, using the new Redis Modules API to extend Redis\nwith new commands and capabilities. Its main features include:\n- Simple, fast indexing and querying\n- Data stored in RAM, using memory-efficient custom data structures\n- On disk persistence\n- Tabular result sets\n- Simple and popular graph query language (Cypher)\n- Data Filtering, Aggregation and ordering", 
            "title": "RedisGraph At-a-Glance"
        }, 
        {
            "location": "/design/#a-little-taste-redisgraph-in-action", 
            "text": "Let\u2019s look at some of the key concepts of RedisGraph using this example over the redis-cli tool:", 
            "title": "A Little Taste: RedisGraph in Action"
        }, 
        {
            "location": "/design/#constructing-a-graph", 
            "text": "It is a common concept to represent entities as nodes within a graph, In this example, we'll create a small graph with both actors and movies as its entities,\nan \"act\" relation will connect actors to movies they casted in.\nWe use the graph.QUERY command to issue a CREATE query which will introduce new entities and relations to our graph.  graph.QUERY  graph_id   CREATE (: label  { attribute_name : attribute_value ,...})   graph.QUERY  graph_id   CREATE ( source_node_alias )-[ relation  { attribute_name : attribute_value ,...}]- ( dest_node_alias )   Construct our graph in one go:  graph.QUERY IMDB  CREATE (aldis:actor {name:  Aldis Hodge , birth_year: 1986}),                           (oshea:actor {name:  OShea Jackson , birth_year: 1991}),                           (corey:actor {name:  Corey Hawkins , birth_year: 1988}),                           (neil:actor {name:  Neil Brown , birth_year: 1980}),                           (compton:movie {title:  Straight Outta Compton , genre:  Biography , votes: 127258, rating: 7.9, year: 2015}),                           (neveregoback:movie {title:  Never Go Back , genre:  Action , votes: 15821, rating: 6.4, year: 2016}),                           (aldis)-[:act]- (neveregoback),                           (aldis)-[:act]- (compton),                           (oshea)-[:act]- (compton),                           (corey)-[:act]- (compton),                           (neil)-[:act]- (compton)", 
            "title": "Constructing a graph:"
        }, 
        {
            "location": "/design/#querying-the-graph", 
            "text": "RedisGraph exposes a subset of openCypher graph language, although only a number of language capabilities are supported\nthere's enough functionality to extract valuable insights from your graphs, to execute a query we use the GRAPH.QUERY\ncommand:  GRAPH.QUERY  graph_id   query   Let's execute a number of queries against our movies graph:  Find the sum, max, min and avg age of the Straight Outta Compton cast:  GRAPH.QUERY IMDB  MATCH (a:actor)-[act]- (m:movie {title: Straight Outta Compton })  RETURN m.title, SUM(a.age), MAX(a.age), MIN(a.age), AVG(a.age)   RedisGraph will reply with:  1 )   m.title, SUM(a.age), MAX(a.age), MIN(a.age), AVG(a.age)  2 )   Straight Outta Compton,123.000000,37.000000,26.000000,30.750000   The first row is our result-set hearder which name each column according to the return clause.\nSecond row contains our query result.  Let's try another query, this time we'll find in how many movies each actor played.  GRAPH.QUERY IMDB  MATCH (actor)-[act]- (movie) RETURN actor.name, COUNT(movie.title) AS movies_count ORDER BY  movies_count DESC  1 )   actor.name, movies_count  2 )   Aldis Hodge,2.000000  3 )   O Shea Jackson,1.000000  4 )   Corey Hawkins,1.000000  5 )   Neil Brown,1.000000", 
            "title": "Querying the graph:"
        }, 
        {
            "location": "/design/#the-theory-ideas-behind-redisgraph", 
            "text": "Different graph databases uses different structures for representing a graph. Some use adjacency list, others might use\nan adjacency matrix. Each structure has its advantages and disadvantages. For RedisGraph it was crucial to find a data\nstructure which will enable us to perform fast searches on the graph, and thus we have decided to use a concept called Hexastore  in order to hold all the relationships within the graph.", 
            "title": "The Theory: Ideas behind RedisGraph"
        }, 
        {
            "location": "/design/#graph-representation-hexastore", 
            "text": "A Hexastore is simply a list of triplets, where each triplet is composed of three parts:   Subject  Predicate  Object   Where the Subject refers to a source node, predicate represents a relationship and the object refers to a destination\nnode.\nFor each relationship within the graph our hexastore will contain all six permutation of the source node, relationship\nedge and destination node.\nFor example consider the following relation:  (Aldis_Hodge)-[act]- (Straight_Outta_Compton)  where:\n- Aldis_Hodge is the source node\n- act is the relationship\n- Straight_Outta_Compton is the destination node  All six possibilities of representing this connection are as follows:  SPO:Aldis_Hodge:act:Straight_Outta_Compton\nSOP:Aldis_Hodge:Straight_Outta_Compton:act\nPOS:act:Straight_Outta_Compton:Aldis_Hodge\nPSO:act:Aldis_Hodge:Straight_Outta_Compton\nOPS:Straight_Outta_Compton:act:Aldis_Hodge\nOSP:Straight_Outta_Compton:Aldis_Hodge:act  With the Hexastore constructed we can easily search our graph, suppose I would like to find the cast of the movie\nStraight Outta Compton, all I've to do is search my Hexastore for all strings containing the\nprefix:  OPS:Straight_Outta_Compton:act:*  Or if I'm interested in all the movies Aldis Hodge played in, I can search for all strings containing the\nprefix:  SPO:Aldis_Hodge:act:*  Although a Hexastore uses plenty of memory (six triplets for each relation), we're using a trie data structure which is\nnot only fast in terms of search but is also memory efficient as it doesn't create duplication of string prefixes it\nalready seen.", 
            "title": "Graph representation: Hexastore"
        }, 
        {
            "location": "/design/#query-language-opencypher", 
            "text": "There are a number of Graph Query languages, we didn't want to reinvent the wheel and come up with our own language,\nand so we've decided to implement a subset of one of the most popular graph query language out there openCypher.\nThe Open-Cypher project provides means to create a parser for the language, although convenient\nwe decided to create our own parser with Lex as a tokenizer and Lemon which generates a C target parser.  As mentioned only a subset of the language is supported, but it is our intention to continue adding new capabilities\nand extend the language.", 
            "title": "Query language: openCypher"
        }, 
        {
            "location": "/design/#runtime-query-execution", 
            "text": "Let's review the steps our module takes when executing a query.\nConsider the following query which finds all actors who've played alongside Aldis Hodge and are over 30 years old:  MATCH (aldis::actor {name: Aldis Hodge })-[act]- (m:movie) -[act]-(a:actor) WHERE a.age   30 RETURN m.title, a.name  RedisGraph will\n- Parse query, build abstract syntax tree (AST)\n- Construct a query execution plan composed of:\n  - Label scan operation\n  - Filter operation (filter tree)\n  - Expand operation\n  - Expand into operation\n- Execute plan\n- Populate result-set with matching entities attributes", 
            "title": "Runtime: query execution"
        }, 
        {
            "location": "/design/#query-parser", 
            "text": "Given a valid query the parser will generate an AST containing six primary nodes one for each clause:   MATCH  CREATE  DELETE  WHERE  RETURN  ORDER   Generating an abstract syntax tree is a common way of describing and structuring a language.", 
            "title": "Query parser"
        }, 
        {
            "location": "/design/#filter-tree", 
            "text": "A query can filter out entities by creating predicates. In our example we're filtering actors which are younger then 30.\nIt's possible to combine predicates using the OR, AND keywords to form granular conditions. During runtime the WHERE\nclause is used to construct a filter tree. Each node within the tree is either a condition e.g. A   B or an operation\n(AND/OR). When finding candidate entities they are passed through the tree and get evaluated.", 
            "title": "Filter tree"
        }, 
        {
            "location": "/design/#query-processing", 
            "text": "The MATCH clause describes relations between queried entities (nodes), a node can have an alias which will allow us to\nrefer to it at later stages within the executing query lifetime (WHERE, RETURN clause), but all nodes must eventually\nbe assign an ID. The process of assigning IDs to nodes is refered to as the search phase.  During the search we'll be querying the Hexastore for IDs according to the MATCH clause structure.\nFor instance, in our example we'll start our search by looking for movies in which Aldis Hodge played in.\nFor each movie we'll extend our search to find out which other actors played in the current processed movie.  As you might imagine the search process is a recursive operation which traverse the graph. At each step a new ID is\ndiscovered. Once every node has an ID assigned to it we can be assured that current entities have passed our filters.\nAt this point we can extract requested attributes (as specified in the return clause) and append a new record to the\nfinal result set.", 
            "title": "Query processing"
        }, 
        {
            "location": "/design/#benchmarks", 
            "text": "Depending on the underlying hardware results may vary. That said, inserting a new relationship is done in O(1).\nRedisGraph is able to create 100K new relations within one second.  Retrieving data really depends on the size of the graph and the type of query you're executing.\nOn a small size graph ~1000 entities and ~2500 edges, RedisGraph is able to perform ~65K friend of a friend query\nevery second.  It's worth mentioning that besides the hexastore, entities are not indexed. It\u2019s our intention to introduce entities\nindexing which should decrease query execution time dramatically.", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/design/#license", 
            "text": "Redis-Graph is published under AGPL-3.0.", 
            "title": "License"
        }, 
        {
            "location": "/design/#conclusion", 
            "text": "Although RedisGraph is still a young project, it can be an alternative to other graph databases. With its subset of\noperations one can use it to analyze and explore its graph data. Being a Redis module this project is accessible from\nevery Redis client without the need to make any adjustments. It's our intention to keep on improving and extending\nRedisGraph with the help of the open source community.", 
            "title": "Conclusion"
        }, 
        {
            "location": "/docker/", 
            "text": "Docker\n\n\nUsing Docker\n\n\nBuild Docker image\n\n\nRedisGraph's \nDockerfile\n uses a recent verion of Docker in order to take\nadvantage of features such as \nbuild stages\n.\nTo build RedisGraph Docker images, you will need a version of Docker equal to\nor greater than 17.05. To update the Docker on your system, see the\n\nDocker update documentation\n\nfor your OS.\n\n\nThe RedisGraph Docker build has been updated to run the tests after compiling\nthe module, so running the tests with Docker is simply a matter of executing\nthe following:\n\n\n$ make docker\n\n\n\n\n\nAs the output scrolls by, towards the end you will see the tests get run, and\nif all goes as expected, you will see them all pass.\n\n\nRunning within a Docker container\n\n\nTo run RedisGraph within docker simply execute:\n\n\n$ docker run -p 6379:6379 redislabs/redisgraph", 
            "title": "Docker"
        }, 
        {
            "location": "/docker/#docker", 
            "text": "", 
            "title": "Docker"
        }, 
        {
            "location": "/docker/#using-docker", 
            "text": "", 
            "title": "Using Docker"
        }, 
        {
            "location": "/docker/#build-docker-image", 
            "text": "RedisGraph's  Dockerfile  uses a recent verion of Docker in order to take\nadvantage of features such as  build stages .\nTo build RedisGraph Docker images, you will need a version of Docker equal to\nor greater than 17.05. To update the Docker on your system, see the Docker update documentation \nfor your OS.  The RedisGraph Docker build has been updated to run the tests after compiling\nthe module, so running the tests with Docker is simply a matter of executing\nthe following:  $ make docker  As the output scrolls by, towards the end you will see the tests get run, and\nif all goes as expected, you will see them all pass.", 
            "title": "Build Docker image"
        }, 
        {
            "location": "/docker/#running-within-a-docker-container", 
            "text": "To run RedisGraph within docker simply execute:  $ docker run -p 6379:6379 redislabs/redisgraph", 
            "title": "Running within a Docker container"
        }
    ]
}